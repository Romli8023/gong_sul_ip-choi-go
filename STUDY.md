# 자이로 센서와 PID 제어 학습 정리

## 1. 자이로 센서의 측정 원리
자이로 센서(Gyro Sensor)는 기본적으로 **각속도(Angular Velocity)**를 측정한다. 즉, 물체가 '얼마나 빠른 속도로 회전하고 있는가'를 감지하는 센서다.

반면에 수평 유지 장치(Balancing Robot)가 제어를 위해 필요로 하는 값은 **현재의 기울어진 총 각도(Total Angle)**이다. 이를 구하기 위해 센서는 다음과 같은 과정을 거친다.

1. 자이로 센서가 아주 짧은 시간($dt$) 동안의 회전 속도를 측정한다.
2. 이 속도 값들을 지속적으로 더해서(적분) **총 이동 거리(각도)**를 계산한다.
3. `gyro_roll.angle()` 함수는 이 적분 과정을 내부적으로 처리하여, 초기 상태 대비 현재 얼마나 회전했는지에 대한 최종 각도 값을 반환한다.

---

## 2. PID 제어 알고리즘 (PID Control)
PID 알고리즘은 로봇의 목표 상태인 **수평($\text{target} = 0$)**을 달성하기 위해, 현재 상태($\text{angle}$)를 바탕으로 모터의 출력($\text{output}$)을 지속적으로 조절하는 피드백 제어 방식이다.

`while True` 루프를 통해 끊임없이 output 값을 수정하며 다음 3가지 요소를 조합한다.

### 2.1. P 제어 (Proportional, 비례)
현재 발생한 오차에 비례하여 반대 방향으로 힘을 가한다. (스프링과 유사한 역할)

$$\text{error} = \text{target} - \text{angle}$$
$$\text{output}_p = K_p \times \text{error}$$

* **작동 원리:** 기울어진 만큼 반대로 밀어낸다.
    * 예: 각도가 +10도 기울어지면 ($\text{error} = -10$), 모터는 음(-)의 방향으로 힘을 낸다.
    * 예: 각도가 +30도 기울어지면, $K_p$에 비례하여 **3배 더 강한 힘**으로 밀어낸다.
* **한계:** 미세한 오차나 로봇의 무게 중심 불균형으로 인해 목표값(0)에 완전히 도달하지 못할 수 있다.

### 2.2. I 제어 (Integral, 적분)
오차가 해결되지 않고 지속되면, 시간이 지날수록 힘을 누적시켜 더 강하게 밀어준다.

$$\text{integral} += \text{error}$$
$$\text{output}_i = K_i \times \text{integral}$$

* **작동 원리:** $K_p$만으로 해결되지 않는 오차가 계속 유지될 경우, $K_i$ 값을 곱해주어 더 큰 힘으로 목표를 맞추도록 돕는다.
* **주의점:** 적분값이 과도하게 쌓이면 목표 지점에 도달해서도 멈추지 못하고 반대편으로 튀어 나가는 과도한 진동(Overshoot)을 유발할 수 있다.

### 2.3. D 제어 (Derivative, 미분)
오차가 변화하는 속도를 감지하여 급격한 움직임에 제동을 건다. (브레이크 역할)

$$\text{deviation} = \text{error} - \text{prev\_error}$$
$$\text{prev\_error} = \text{error}$$
$$\text{output}_d = K_d \times \text{deviation}$$

* **작동 원리:** '오차가 얼마나 빠르게 변하고 있는가?'를 계산한다.
    * 로봇이 0도를 향해 너무 빠른 속도로 돌진하면 `deviation` 값이 매우 크게 측정된다.
    * $K_d$ 항은 이 '돌진하는 힘'에 반대되는 **제동력**을 발생시켜, 로봇이 목표 지점을 지나치기 전에 미리 속도를 줄이도록 만든다.

---

## 3. 최종 구현 로직
위의 3가지 제어 방식을 합산하여 최종 모터 출력을 결정한다.

```python
# 1. P, I, D의 힘을 모두 합산하여 최종 명령 생성
output = (Kp * error) + (Ki * integral) + (Kd * deviation)

# 2. 최종 명령(output)을 모터의 '속도'로 전달
motor_roll.run(output)
